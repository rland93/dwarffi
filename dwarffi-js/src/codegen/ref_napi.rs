/// JavaScript code generation using ref-napi ecosystem
/// (ref-napi, ref-struct-di, ref-array-di, ref-union-di)

use anyhow::{anyhow, Result};
use dwarffi::{
    BaseTypeKind, EnumVariant, FunctionSignature, StructField, Type, TypeId, TypeRegistry,
    UnionField,
};
use std::collections::HashSet;

/// Context for type expression generation
#[derive(Clone, Copy)]
enum TypeContext {
    StructField,   // Full type definitions for struct fields
    FunctionParam, // ffi-napi shortcuts for function parameters
}

/// Generate complete JavaScript module using ref-napi/ffi-napi
pub fn generate(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
    generate_types: bool,
    generate_functions: bool,
    library_path: &str,
) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str(&generate_header());

    // Imports
    output.push_str(&generate_imports(generate_functions));

    // Primitive type aliases
    output.push_str(&generate_primitives());

    // Get types that need to be generated (from function signatures)
    let required_types = collect_required_types(type_registry, functions)?;

    let mut generated_names = HashSet::new();

    if generate_types {
    // Topological sort to handle dependencies
    let sorted_types = topological_sort(type_registry, required_types)?;

    // Generate type definitions in dependency order
    for type_id in sorted_types {
        if let Some(type_) = type_registry.get_type(type_id) {
            let type_def = generate_type_definition(
                type_registry,
                type_,
                &mut generated_names,
            )?;
            output.push_str(&type_def);
        }
    }
    }

    if generate_functions {
    // Generate function bindings
    output.push_str(&generate_function_bindings(
        type_registry,
        functions,
        library_path,
    )?);
    }

    // Exports
    output.push_str(&generate_exports(
    type_registry,
    functions,
    generate_types,
    generate_functions,
    &generated_names,
    )?);

    Ok(output)
}

fn generate_header() -> String {
    format!(
    "// Auto-generated by dwarffi-js\n\
     // Do not edit manually - regenerate from your C library\n\n"
    )
}

fn generate_imports(include_ffi: bool) -> String {
    let mut imports = String::from("const ref = require('ref-napi')\n");

    if include_ffi {
    imports.push_str("const ffi = require('ffi-napi')\n");
    }

    imports.push_str(
    "const StructType = require('ref-struct-di')(ref)\n\
     const ArrayType = require('ref-array-di')(ref)\n\
     const UnionType = require('ref-union-di')(ref)\n\n",
    );

    imports
    }

fn generate_primitives() -> String {
    "// Primitive type aliases for convenience\n\
     const void_ = ref.types.void\n\
     const bool_ = ref.types.bool\n\
     const int8 = ref.types.int8\n\
     const uint8 = ref.types.uint8\n\
     const int16 = ref.types.int16\n\
     const uint16 = ref.types.uint16\n\
     const int32 = ref.types.int32\n\
     const uint32 = ref.types.uint32\n\
     const int64 = ref.types.int64\n\
     const uint64 = ref.types.uint64\n\
     const float = ref.types.float\n\
     const double = ref.types.double\n\
     const char = ref.types.char\n\
     const uchar = ref.types.uchar\n\
     const short = ref.types.short\n\
     const ushort = ref.types.ushort\n\
     const int = ref.types.int\n\
     const uint = ref.types.uint\n\
     const long = ref.types.long\n\
     const ulong = ref.types.ulong\n\
     const longlong = ref.types.longlong\n\
     const ulonglong = ref.types.ulonglong\n\
     const size_t = ref.types.size_t\n\n"
    .to_string()
    }

    /// Collect all types referenced by function signatures
fn collect_required_types(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
    ) -> Result<HashSet<TypeId>> {
    let mut required = HashSet::new();

    for func in functions {
    // Add return type
    add_type_transitive(type_registry, func.return_type_id, &mut required)?;

    // Add parameter types
    for param in &func.parameters {
        add_type_transitive(type_registry, param.type_id, &mut required)?;
    }
    }

    Ok(required)
    }

    /// Recursively add a type and all types it references
fn add_type_transitive(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    collected: &mut HashSet<TypeId>,
    ) -> Result<()> {
    if collected.contains(&type_id) {
    return Ok(());
    }

    let type_ = type_registry
    .get_type(type_id)
    .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // Skip primitives - they don't need definitions
    if matches!(&type_.kind, BaseTypeKind::Primitive { .. }) {
    return Ok(());
    }

    collected.insert(type_id);

    // Recursively collect referenced types
    match &type_.kind {
    BaseTypeKind::Struct { fields, .. } => {
        for field in fields {
            add_type_transitive(type_registry, field.type_id, collected)?;
        }
    }
    BaseTypeKind::Union { variants, .. } => {
        for variant in variants {
            add_type_transitive(type_registry, variant.type_id, collected)?;
        }
    }
    BaseTypeKind::Enum { backing_id, .. } => {
        add_type_transitive(type_registry, *backing_id, collected)?;
    }
    BaseTypeKind::Array {
        element_type_id, ..
    } => {
        add_type_transitive(type_registry, *element_type_id, collected)?;
    }
    BaseTypeKind::Typedef { aliased_type_id, .. } => {
        add_type_transitive(type_registry, *aliased_type_id, collected)?;
    }
    BaseTypeKind::Function {
        return_type_id,
        parameter_type_ids,
        ..
    } => {
        if let Some(ret_id) = return_type_id {
            add_type_transitive(type_registry, *ret_id, collected)?;
        }
        for param_id in parameter_type_ids {
            add_type_transitive(type_registry, *param_id, collected)?;
        }
    }
    BaseTypeKind::Primitive { .. } => {}
    }

    Ok(())
    }

    /// Topological sort types by dependencies
fn topological_sort(
    type_registry: &TypeRegistry,
    types: HashSet<TypeId>,
    ) -> Result<Vec<TypeId>> {
    let mut sorted = Vec::new();
    let mut visited = HashSet::new();
    let mut visiting = HashSet::new();

    for &type_id in &types {
    visit_type(
        type_registry,
        type_id,
        &types,
        &mut visited,
        &mut visiting,
        &mut sorted,
    )?;
    }

    Ok(sorted)
    }

fn visit_type(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    all_types: &HashSet<TypeId>,
    visited: &mut HashSet<TypeId>,
    visiting: &mut HashSet<TypeId>,
    sorted: &mut Vec<TypeId>,
    ) -> Result<()> {
    if visited.contains(&type_id) {
    return Ok(());
    }

    if visiting.contains(&type_id) {
    // Circular dependency - this is OK for pointers
    return Ok(());
    }

    let type_ = type_registry
    .get_type(type_id)
    .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    visiting.insert(type_id);

    // Visit dependencies first
    match &type_.kind {
    BaseTypeKind::Struct { fields, .. } => {
        for field in fields {
            // Only visit if it's in our required set and not a pointer
            // (pointers can reference types that come later)
            let field_type = type_registry.get_type(field.type_id);
            if all_types.contains(&field.type_id)
                && field_type.map(|t| t.pointer_depth == 0).unwrap_or(false)
            {
                visit_type(
                    type_registry,
                    field.type_id,
                    all_types,
                    visited,
                    visiting,
                    sorted,
                )?;
            }
        }
    }
    BaseTypeKind::Union { variants, .. } => {
        for variant in variants {
            let variant_type = type_registry.get_type(variant.type_id);
            if all_types.contains(&variant.type_id)
                && variant_type.map(|t| t.pointer_depth == 0).unwrap_or(false)
            {
                visit_type(
                    type_registry,
                    variant.type_id,
                    all_types,
                    visited,
                    visiting,
                    sorted,
                )?;
            }
        }
    }
    BaseTypeKind::Array {
        element_type_id, ..
    } => {
        if all_types.contains(element_type_id) {
            visit_type(
                type_registry,
                *element_type_id,
                all_types,
                visited,
                visiting,
                sorted,
            )?;
        }
    }
    BaseTypeKind::Typedef { aliased_type_id, .. } => {
        if all_types.contains(aliased_type_id) {
            visit_type(
                type_registry,
                *aliased_type_id,
                all_types,
                visited,
                visiting,
                sorted,
            )?;
        }
    }
    _ => {}
    }

    visiting.remove(&type_id);
    visited.insert(type_id);
    sorted.push(type_id);

    Ok(())
    }

    /// Generate a single type definition
fn generate_type_definition(
    type_registry: &TypeRegistry,
    type_: &Type,
    generated_names: &mut HashSet<String>,
    ) -> Result<String> {
    // Get the type name for deduplication
    let type_name = match &type_.kind {
    BaseTypeKind::Struct { name, .. } => Some(name.clone()),
    BaseTypeKind::Union { name, .. } => Some(name.clone()),
    BaseTypeKind::Enum { name, .. } => Some(name.clone()),
    BaseTypeKind::Typedef { name, .. } => Some(name.clone()),
    _ => None,
    };

    // Skip if already generated
    if let Some(ref name) = type_name {
    if generated_names.contains(name) {
        return Ok(String::new());
    }
    }

    let result = match &type_.kind {
    BaseTypeKind::Primitive { .. } => {
        // Primitives are handled in the header
        Ok(String::new())
    }
    BaseTypeKind::Struct {
        name,
        fields,
        is_opaque,
        ..
    } => {
        // Skip anonymous structs - they'll be referenced by their typedef
        if name.starts_with("<") {
            return Ok(String::new());
        }
        generate_struct(type_registry, name, fields, *is_opaque)
    }
    BaseTypeKind::Union {
        name, variants, ..
    } => {
        // Skip anonymous unions
        if name.starts_with("<") {
            return Ok(String::new());
        }
        generate_union(type_registry, name, variants)
    }
    BaseTypeKind::Enum {
        name, variants, ..
    } => {
        // Skip anonymous enums
        if name.starts_with("<") {
            return Ok(String::new());
        }
        generate_enum(name, variants)
    }
    BaseTypeKind::Array { .. } => {
        // Arrays are generated inline in struct fields
        Ok(String::new())
    }
    BaseTypeKind::Typedef {
        name,
        aliased_type_id,
    } => generate_typedef(type_registry, name, *aliased_type_id, generated_names),
    BaseTypeKind::Function { .. } => {
        // Function pointers are generated inline
        Ok(String::new())
    }
    };

    // Mark as generated if successful
    if let Some(name) = type_name {
    if result.is_ok() && !result.as_ref().unwrap().is_empty() {
        generated_names.insert(name);
    }
    }

    result
    }

fn generate_struct(
    type_registry: &TypeRegistry,
    name: &str,
    fields: &[StructField],
    is_opaque: bool,
    ) -> Result<String> {
    let mut output = String::new();

    if is_opaque {
    output.push_str(&format!(
        "// {} (opaque - no definition available)\n",
        name
    ));
    output.push_str(&format!("const {} = ref.types.void // treat as opaque handle\n\n", name));
    return Ok(output);
    }

    output.push_str(&format!("const {} = StructType({{\n", name));

    for field in fields {
    let field_type =
        type_to_js_expr(type_registry, field.type_id, TypeContext::StructField)?;
    output.push_str(&format!("  {}: {},\n", field.name, field_type));
    }

    output.push_str("})\n\n");

    Ok(output)
    }

fn generate_union(
    type_registry: &TypeRegistry,
    name: &str,
    variants: &[UnionField],
    ) -> Result<String> {
    let mut output = String::new();

    output.push_str(&format!("const {} = UnionType({{\n", name));

    for variant in variants {
    let variant_type =
        type_to_js_expr(type_registry, variant.type_id, TypeContext::StructField)?;
    output.push_str(&format!("  {}: {},\n", variant.name, variant_type));
    }

    output.push_str("})\n\n");

    Ok(output)
    }

fn generate_enum(name: &str, variants: &[EnumVariant]) -> Result<String> {
    let mut output = String::new();

    output.push_str(&format!("const {} = {{\n", name));

    for variant in variants {
    output.push_str(&format!("  {}: {},\n", variant.name, variant.value));
    }

    output.push_str("}\n\n");

    Ok(output)
    }

fn generate_typedef(
    type_registry: &TypeRegistry,
    name: &str,
    aliased_type_id: TypeId,
    generated_names: &mut HashSet<String>,
    ) -> Result<String> {
    let aliased_type = type_registry
    .get_type(aliased_type_id)
    .ok_or_else(|| anyhow!("Aliased type not found"))?;

    // Skip typedefs that are just primitive aliases (e.g., typedef unsigned long size_t)
    // where we already have size_t in our primitives
    let is_primitive_alias = matches!(&aliased_type.kind, BaseTypeKind::Primitive { .. })
    && primitive_to_js(name).is_ok();

    if is_primitive_alias {
    return Ok(String::new());
    }

    // If typedef is to an anonymous struct/union/enum, generate the full definition
    match &aliased_type.kind {
    BaseTypeKind::Struct { name: struct_name, fields, is_opaque, .. }
        if struct_name.starts_with("<") =>
    {
        generate_struct(type_registry, name, fields, *is_opaque)
    }
    BaseTypeKind::Union { name: union_name, variants, .. }
        if union_name.starts_with("<") =>
    {
        generate_union(type_registry, name, variants)
    }
    BaseTypeKind::Enum { name: enum_name, variants, .. }
        if enum_name.starts_with("<") =>
    {
        generate_enum(name, variants)
    }
    _ => {
        // Check if the aliased type has a named definition
        let aliased_name = match &aliased_type.kind {
            BaseTypeKind::Struct { name, .. } => Some(name.as_str()),
            BaseTypeKind::Union { name, .. } => Some(name.as_str()),
            BaseTypeKind::Enum { name, .. } => Some(name.as_str()),
            _ => None,
        };

        // If typedef aliases a named type that's already generated, just skip it
        if let Some(aliased) = aliased_name {
            if generated_names.contains(aliased) && aliased == name {
                return Ok(String::new());
            }
        }

        // Regular typedef - just create an alias
        let aliased_expr =
            type_to_js_expr(type_registry, aliased_type_id, TypeContext::StructField)?;
        Ok(format!("const {} = {}\n\n", name, aliased_expr))
    }
    }
    }

    /// Convert a TypeId to a JavaScript expression (e.g., "int", "ref.refType(int)", "Point")
fn type_to_js_expr(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    context: TypeContext,
    ) -> Result<String> {
    let type_ = type_registry
    .get_type(type_id)
    .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // Handle special cases for function parameters (ffi-napi shortcuts)
    if matches!(context, TypeContext::FunctionParam) {
    // const char* → 'string' in ffi-napi
    if type_.pointer_depth == 1 && type_.is_const {
        if let BaseTypeKind::Primitive { name, .. } = &type_.kind {
            if name == "char" {
                return Ok("'string'".to_string());
            }
        }
    }
    // void* → 'pointer'
    if type_.pointer_depth == 1 {
        if let BaseTypeKind::Primitive { name, .. } = &type_.kind {
            if name == "void" {
                return Ok("'pointer'".to_string());
            }
        }
    }
    }

    // Get the base type expression
    let base_expr = match &type_.kind {
    BaseTypeKind::Primitive { name, .. } => {
        if matches!(context, TypeContext::FunctionParam) {
            // For function params, use string literals
            primitive_to_ffi_string(name)?
        } else {
            // For struct fields, use type references
            primitive_to_js(name)?
        }
    }
    BaseTypeKind::Struct { name, .. } => name.clone(),
    BaseTypeKind::Union { name, .. } => name.clone(),
    BaseTypeKind::Enum { .. } => {
        // Enums in C are just integers
        if matches!(context, TypeContext::FunctionParam) {
            "'int'".to_string()
        } else {
            "int".to_string()
        }
    }
    BaseTypeKind::Array {
        element_type_id,
        count,
        ..
    } => {
        let elem_expr =
            type_to_js_expr(type_registry, *element_type_id, TypeContext::StructField)?;
        format!("ArrayType({})({})", elem_expr, count)
    }
    BaseTypeKind::Typedef { name, .. } => name.clone(),
    BaseTypeKind::Function { .. } => {
        // Function pointers are just void* in practice for FFI
        "ref.types.void".to_string()
    }
    };

    // Apply pointer depth
    let mut expr = base_expr;
    for _ in 0..type_.pointer_depth {
    expr = format!("ref.refType({})", expr);
    }

    Ok(expr)
    }

    /// Map C primitive type names to ref.types expressions
fn primitive_to_js(c_name: &str) -> Result<String> {
    let js_name = match c_name {
    "void" => "void_",
    "bool" | "_Bool" => "bool_",
    "char" => "char",
    "signed char" => "char",
    "unsigned char" => "uchar",
    "short" | "short int" | "signed short" | "signed short int" => "short",
    "unsigned short" | "unsigned short int" => "ushort",
    "int" | "signed int" | "signed" => "int",
    "unsigned int" | "unsigned" => "uint",
    "long" | "long int" | "signed long" | "signed long int" => "long",
    "unsigned long" | "unsigned long int" => "ulong",
    "long long" | "long long int" | "signed long long" | "signed long long int" => {
        "longlong"
    }
    "unsigned long long" | "unsigned long long int" => "ulonglong",
    "float" => "float",
    "double" => "double",
    "long double" => "double", // JavaScript doesn't have long double
    // Fixed-width types
    "int8_t" => "int8",
    "uint8_t" => "uint8",
    "int16_t" => "int16",
    "uint16_t" => "uint16",
    "int32_t" => "int32",
    "uint32_t" => "uint32",
    "int64_t" => "int64",
    "uint64_t" => "uint64",
    "size_t" => "size_t",
    "ssize_t" => "int64", // Map to int64 as fallback
    "ptrdiff_t" => "int64",
    "intptr_t" => "int64",
    "uintptr_t" => "uint64",
    _ => {
        return Err(anyhow!("Unknown primitive type: {}", c_name));
    }
    };

    Ok(js_name.to_string())
    }

    /// Map C primitive type names to ffi-napi string literals for function signatures
fn primitive_to_ffi_string(c_name: &str) -> Result<String> {
    let ffi_string = match c_name {
    "void" => "'void'",
    "bool" | "_Bool" => "'bool'",
    "char" => "'char'",
    "signed char" => "'char'",
    "unsigned char" => "'uchar'",
    "short" | "short int" | "signed short" | "signed short int" => "'short'",
    "unsigned short" | "unsigned short int" => "'ushort'",
    "int" | "signed int" | "signed" => "'int'",
    "unsigned int" | "unsigned" => "'uint'",
    "long" | "long int" | "signed long" | "signed long int" => "'long'",
    "unsigned long" | "unsigned long int" => "'ulong'",
    "long long" | "long long int" | "signed long long" | "signed long long int" => "'longlong'",
    "unsigned long long" | "unsigned long long int" => "'ulonglong'",
    "float" => "'float'",
    "double" => "'double'",
    "long double" => "'double'",
    "int8_t" => "'int8'",
    "uint8_t" => "'uint8'",
    "int16_t" => "'int16'",
    "uint16_t" => "'uint16'",
    "int32_t" => "'int32'",
    "uint32_t" => "'uint32'",
    "int64_t" => "'int64'",
    "uint64_t" => "'uint64'",
    "size_t" => "'size_t'",
    "ssize_t" => "'int64'",
    "ptrdiff_t" => "'int64'",
    "intptr_t" => "'int64'",
    "uintptr_t" => "'uint64'",
    _ => {
        return Err(anyhow!("Unknown primitive type for FFI: {}", c_name));
    }
    };

    Ok(ffi_string.to_string())
    }

    /// Generate ffi.Library() function bindings
fn generate_function_bindings(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
    library_path: &str,
    ) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Library path - UPDATE THIS to match your deployment\n");
    output.push_str(&format!("const LIBRARY_PATH = '{}'\n\n", library_path));

    output.push_str("// Function bindings\n");
    output.push_str("const lib = ffi.Library(LIBRARY_PATH, {\n");

    for func in functions {
    if func.is_variadic {
        // Variadic functions not supported by ffi-napi
        output.push_str(&format!(
            "  // '{}': variadic function not supported by ffi-napi\n",
            func.name
        ));
        continue;
    }

    // Return type
    let return_type = type_to_js_expr(
        type_registry,
        func.return_type_id,
        TypeContext::FunctionParam,
    )?;

    // Parameter types
    let param_types: Result<Vec<String>> = func
        .parameters
        .iter()
        .map(|p| {
            type_to_js_expr(type_registry, p.type_id, TypeContext::FunctionParam)
        })
        .collect();
    let param_types = param_types?;

    output.push_str(&format!(
        "  '{}': [ {}, [ {} ] ],\n",
        func.name,
        return_type,
        param_types.join(", ")
    ));
    }

    output.push_str("})\n\n");

    Ok(output)
    }

fn generate_exports(
    _type_registry: &TypeRegistry,
    _functions: &[FunctionSignature],
    generate_types: bool,
    generate_functions: bool,
    generated_names: &HashSet<String>,
    ) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Exports\n");
    output.push_str("module.exports = {\n");

    if generate_functions {
    // Export types under 'types' namespace and lib
    if generate_types {
        output.push_str("  types: {\n");

        for name in generated_names {
            output.push_str(&format!("    {},\n", name));
        }

        output.push_str("  },\n");
    }
    output.push_str("  lib\n");
    } else if generate_types {
    // Export types directly
    for name in generated_names {
        output.push_str(&format!("  {},\n", name));
    }
    }

    output.push_str("}\n");

    Ok(output)
}
