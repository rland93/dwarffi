/// javascript code generation using koffi
/// (https://koffi.dev)
use anyhow::{Result, anyhow};
use dwarffi::{
    BaseTypeKind, EnumVariant, FunctionSignature, StructField, Type, TypeId, TypeRegistry,
    UnionField,
};
use std::collections::HashSet;

pub fn generate(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
    generate_types: bool,
    generate_functions: bool,
    library_path: &str,
) -> Result<String> {
    let mut output = String::new();

    output.push_str(&generate_header());

    output.push_str(&generate_imports());

    // need types that are referenced in functions
    let required_types = collect_required_types(type_registry, functions)?;

    let mut generated_names = HashSet::new();

    if generate_types {
        let sorted_types = topological_sort(type_registry, required_types)?;

        // dependency order
        for type_id in sorted_types {
            if let Some(type_) = type_registry.get_type(type_id) {
                let type_def =
                    generate_type_definition(type_registry, type_, &mut generated_names)?;
                output.push_str(&type_def);
            }
        }
    }

    if generate_functions {
        let callback_types = collect_callback_types(type_registry, functions)?;

        // in koffi, callbacks need to be created with .proto() before library
        // is loaded, so do that first.
        if !callback_types.is_empty() {
            output.push_str(&generate_callback_protos(type_registry, &callback_types)?);
        }

        output.push_str(&generate_function_bindings(
            type_registry,
            functions,
            library_path,
        )?);
    }

    output.push_str(&generate_exports(
        generate_types,
        generate_functions,
        &generated_names,
        functions,
    )?);

    Ok(output)
}

fn generate_header() -> String {
    "// Auto-generated by dwarffi-js\n\
         // Do not edit manually!\n\
         // Backend: Koffi (https://koffi.dev)\n\
         //\n\
         // `npm install koffi` in your project to use the generated bindings\n"
        .to_string()
}

fn generate_imports() -> String {
    "const koffi = require('koffi')\n\n".to_string()
}

/// collect all types referenced by function signatures
fn collect_required_types(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
) -> Result<HashSet<TypeId>> {
    let mut required = HashSet::new();

    for func in functions {
        // add return type
        add_type_transitive(type_registry, func.return_type_id, &mut required)?;

        // add parameter types
        for param in &func.parameters {
            add_type_transitive(type_registry, param.type_id, &mut required)?;
        }
    }

    Ok(required)
}

/// collect all function pointer types (callbacks) used in function signatures
fn collect_callback_types(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
) -> Result<Vec<(String, TypeId)>> {
    let mut callbacks = Vec::new();
    let mut seen = HashSet::new();

    for func in functions {
        // check return type
        collect_callbacks_from_type(
            type_registry,
            func.return_type_id,
            &mut callbacks,
            &mut seen,
        )?;

        // check parameter types
        for param in &func.parameters {
            collect_callbacks_from_type(type_registry, param.type_id, &mut callbacks, &mut seen)?;
        }
    }

    Ok(callbacks)
}

/// recursively collect function pointer types from a type
fn collect_callbacks_from_type(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    callbacks: &mut Vec<(String, TypeId)>,
    seen: &mut HashSet<TypeId>,
) -> Result<()> {
    if seen.contains(&type_id) {
        return Ok(());
    }
    seen.insert(type_id);

    let type_ = type_registry
        .get_type(type_id)
        .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // check if this is a function pointer (pointer to function)
    if type_.pointer_depth > 0
        && let BaseTypeKind::Function { .. } = &type_.kind
    {
        // this is a function pointer - but we need to find its typedef name
        // look for a typedef that points to this function type
        // for now, we'll handle typedefs to function pointers
        return Ok(());
    }

    // check if this is a typedef to a function pointer
    if let BaseTypeKind::Typedef {
        name,
        aliased_type_id,
    } = &type_.kind
    {
        let aliased = type_registry
            .get_type(*aliased_type_id)
            .ok_or_else(|| anyhow!("Aliased type not found"))?;

        // check if typedef points to a function pointer
        if aliased.pointer_depth > 0
            && let BaseTypeKind::Function { .. } = &aliased.kind
        {
            // This is a typedef to a function pointer (e.g., "typedef void (*Callback)(...)")
            callbacks.push((name.clone(), *aliased_type_id));
            return Ok(());
        }
    }

    // recursively check composite types
    match &type_.kind {
        BaseTypeKind::Struct { fields, .. } => {
            for field in fields {
                collect_callbacks_from_type(type_registry, field.type_id, callbacks, seen)?;
            }
        }
        BaseTypeKind::Array {
            element_type_id, ..
        } => {
            collect_callbacks_from_type(type_registry, *element_type_id, callbacks, seen)?;
        }
        _ => {}
    }

    Ok(())
}

/// recursively add a type and all types it references
fn add_type_transitive(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    collected: &mut HashSet<TypeId>,
) -> Result<()> {
    if collected.contains(&type_id) {
        return Ok(());
    }

    let type_ = type_registry
        .get_type(type_id)
        .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // skip primitives - they don't need definitions
    if matches!(&type_.kind, BaseTypeKind::Primitive { .. }) {
        return Ok(());
    }

    collected.insert(type_id);

    // recursively collect referenced types
    match &type_.kind {
        BaseTypeKind::Struct { fields, .. } => {
            for field in fields {
                add_type_transitive(type_registry, field.type_id, collected)?;
            }
        }
        BaseTypeKind::Union { variants, .. } => {
            for variant in variants {
                add_type_transitive(type_registry, variant.type_id, collected)?;
            }
        }
        BaseTypeKind::Enum { backing_id, .. } => {
            add_type_transitive(type_registry, *backing_id, collected)?;
        }
        BaseTypeKind::Array {
            element_type_id, ..
        } => {
            add_type_transitive(type_registry, *element_type_id, collected)?;
        }
        BaseTypeKind::Typedef {
            aliased_type_id, ..
        } => {
            add_type_transitive(type_registry, *aliased_type_id, collected)?;
        }
        BaseTypeKind::Function {
            return_type_id,
            parameter_type_ids,
            ..
        } => {
            if let Some(ret_id) = return_type_id {
                add_type_transitive(type_registry, *ret_id, collected)?;
            }
            for param_id in parameter_type_ids {
                add_type_transitive(type_registry, *param_id, collected)?;
            }
        }
        BaseTypeKind::Primitive { .. } => {}
    }

    Ok(())
}

/// sort types by dependencies
fn topological_sort(type_registry: &TypeRegistry, types: HashSet<TypeId>) -> Result<Vec<TypeId>> {
    let mut sorted = Vec::new();
    let mut visited = HashSet::new();
    let mut visiting = HashSet::new();

    for &type_id in &types {
        visit_type(
            type_registry,
            type_id,
            &types,
            &mut visited,
            &mut visiting,
            &mut sorted,
        )?;
    }

    Ok(sorted)
}

fn visit_type(
    type_registry: &TypeRegistry,
    type_id: TypeId,
    all_types: &HashSet<TypeId>,
    visited: &mut HashSet<TypeId>,
    visiting: &mut HashSet<TypeId>,
    sorted: &mut Vec<TypeId>,
) -> Result<()> {
    if visited.contains(&type_id) {
        return Ok(());
    }

    if visiting.contains(&type_id) {
        // circular dependency - this is OK for pointers
        return Ok(());
    }

    let type_ = type_registry
        .get_type(type_id)
        .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    visiting.insert(type_id);

    // visit dependencies first
    match &type_.kind {
        BaseTypeKind::Struct { fields, .. } => {
            for field in fields {
                // only visit if it's in our required set and not a pointer
                let field_type = type_registry.get_type(field.type_id);
                if all_types.contains(&field.type_id)
                    && field_type.map(|t| t.pointer_depth == 0).unwrap_or(false)
                {
                    visit_type(
                        type_registry,
                        field.type_id,
                        all_types,
                        visited,
                        visiting,
                        sorted,
                    )?;
                }
            }
        }
        BaseTypeKind::Union { variants, .. } => {
            for variant in variants {
                let variant_type = type_registry.get_type(variant.type_id);
                if all_types.contains(&variant.type_id)
                    && variant_type.map(|t| t.pointer_depth == 0).unwrap_or(false)
                {
                    visit_type(
                        type_registry,
                        variant.type_id,
                        all_types,
                        visited,
                        visiting,
                        sorted,
                    )?;
                }
            }
        }
        BaseTypeKind::Array {
            element_type_id, ..
        } => {
            if all_types.contains(element_type_id) {
                visit_type(
                    type_registry,
                    *element_type_id,
                    all_types,
                    visited,
                    visiting,
                    sorted,
                )?;
            }
        }
        BaseTypeKind::Typedef {
            aliased_type_id, ..
        } => {
            if all_types.contains(aliased_type_id) {
                visit_type(
                    type_registry,
                    *aliased_type_id,
                    all_types,
                    visited,
                    visiting,
                    sorted,
                )?;
            }
        }
        _ => {}
    }

    visiting.remove(&type_id);
    visited.insert(type_id);
    sorted.push(type_id);

    Ok(())
}

/// generate a single type definition
fn generate_type_definition(
    type_registry: &TypeRegistry,
    type_: &Type,
    generated_names: &mut HashSet<String>,
) -> Result<String> {
    // get the type name for deduplication
    let type_name = match &type_.kind {
        BaseTypeKind::Struct { name, .. } => Some(name.clone()),
        BaseTypeKind::Union { name, .. } => Some(name.clone()),
        BaseTypeKind::Enum { name, .. } => Some(name.clone()),
        BaseTypeKind::Typedef { name, .. } => Some(name.clone()),
        _ => None,
    };

    // skip if already generated
    if let Some(ref name) = type_name
        && generated_names.contains(name)
    {
        return Ok(String::new());
    }

    let result = match &type_.kind {
        BaseTypeKind::Primitive { .. } => {
            // primitives don't need definitions in Koffi
            Ok(String::new())
        }
        BaseTypeKind::Struct {
            name,
            fields,
            is_opaque,
            ..
        } => {
            // skip anonymous structs - they'll be referenced by their typedef
            if name.starts_with("<") {
                return Ok(String::new());
            }
            generate_struct(type_registry, name, fields, *is_opaque)
        }
        BaseTypeKind::Union { name, variants, .. } => {
            // skip anonymous unions
            if name.starts_with("<") {
                return Ok(String::new());
            }
            generate_union(type_registry, name, variants)
        }
        BaseTypeKind::Enum { name, variants, .. } => {
            // skip anonymous enums
            if name.starts_with("<") {
                return Ok(String::new());
            }
            generate_enum(name, variants)
        }
        BaseTypeKind::Array { .. } => {
            // arrays are generated inline in struct fields
            Ok(String::new())
        }
        BaseTypeKind::Typedef {
            name,
            aliased_type_id,
        } => generate_typedef(type_registry, name, *aliased_type_id, generated_names),
        BaseTypeKind::Function { .. } => {
            // function pointers are generated inline
            Ok(String::new())
        }
    };

    // mark as generated if successful
    if let Some(name) = type_name
        && result.is_ok()
        && !result.as_ref().unwrap().is_empty()
    {
        generated_names.insert(name);
    }

    result
}

fn generate_struct(
    type_registry: &TypeRegistry,
    name: &str,
    fields: &[StructField],
    is_opaque: bool,
) -> Result<String> {
    let mut output = String::new();

    if is_opaque {
        output.push_str(&format!("// {} (opaque - no definition available)\n", name));
        output.push_str(&format!("const {} = koffi.opaque()\n\n", name));
        return Ok(output);
    }

    output.push_str(&format!("const {} = koffi.struct('{}', {{\n", name, name));

    for field in fields {
        let field_type = type_to_koffi_string(type_registry, field.type_id)?;

        // add comment if field is an enum (to help developers)
        let field_type_info = type_registry.get_type(field.type_id);
        if let Some(type_) = field_type_info
            && let BaseTypeKind::Enum {
                name: enum_name, ..
            } = &type_.kind
        {
            output.push_str(&format!(
                "  {}: {},  // {} enum\n",
                field.name, field_type, enum_name
            ));
            continue;
        }

        output.push_str(&format!("  {}: {},\n", field.name, field_type));
    }

    output.push_str("})\n\n");

    Ok(output)
}

fn generate_union(
    type_registry: &TypeRegistry,
    name: &str,
    variants: &[UnionField],
) -> Result<String> {
    let mut output = String::new();

    output.push_str(&format!("const {} = koffi.union('{}', {{\n", name, name));

    for variant in variants {
        let variant_type = type_to_koffi_string(type_registry, variant.type_id)?;
        output.push_str(&format!("  {}: {},\n", variant.name, variant_type));
    }

    output.push_str("})\n\n");

    Ok(output)
}

fn generate_enum(name: &str, variants: &[EnumVariant]) -> Result<String> {
    let mut output = String::new();

    output.push_str(&format!("// Enum: {}\n", name));
    output.push_str(&format!("const {} = {{\n", name));

    for variant in variants {
        output.push_str(&format!("  {}: {},\n", variant.name, variant.value));
    }

    output.push_str("}\n\n");

    Ok(output)
}

fn generate_typedef(
    type_registry: &TypeRegistry,
    name: &str,
    aliased_type_id: TypeId,
    generated_names: &mut HashSet<String>,
) -> Result<String> {
    let aliased_type = type_registry
        .get_type(aliased_type_id)
        .ok_or_else(|| anyhow!("Aliased type not found"))?;

    // skip typedefs that are just primitive aliases
    if matches!(&aliased_type.kind, BaseTypeKind::Primitive { .. }) {
        return Ok(String::new());
    }

    // if typedef is to an anonymous struct/union/enum, generate the full definition
    match &aliased_type.kind {
        BaseTypeKind::Struct {
            name: struct_name,
            fields,
            is_opaque,
            ..
        } if struct_name.starts_with("<") => {
            generate_struct(type_registry, name, fields, *is_opaque)
        }
        BaseTypeKind::Union {
            name: union_name,
            variants,
            ..
        } if union_name.starts_with("<") => generate_union(type_registry, name, variants),
        BaseTypeKind::Enum {
            name: enum_name,
            variants,
            ..
        } if enum_name.starts_with("<") => generate_enum(name, variants),
        _ => {
            // check if the aliased type has a named definition
            let aliased_name = match &aliased_type.kind {
                BaseTypeKind::Struct { name, .. } => Some(name.as_str()),
                BaseTypeKind::Union { name, .. } => Some(name.as_str()),
                BaseTypeKind::Enum { name, .. } => Some(name.as_str()),
                _ => None,
            };

            // if typedef aliases a named type that's already generated, just skip it
            if let Some(aliased) = aliased_name
                && generated_names.contains(aliased)
                && aliased == name
            {
                return Ok(String::new());
            }

            // for Koffi, we don't need to create typedef aliases - just skip
            Ok(String::new())
        }
    }
}

/// convert a TypeId to a Koffi type string (e.g., "'int'", "'Point *'", "koffi.array('char', 64)")
fn type_to_koffi_string(type_registry: &TypeRegistry, type_id: TypeId) -> Result<String> {
    let type_ = type_registry
        .get_type(type_id)
        .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // build the base type string
    let mut type_str = match &type_.kind {
        BaseTypeKind::Primitive { name, .. } => primitive_to_koffi(name)?,
        BaseTypeKind::Struct { name, .. } => format!("'{}'", name),
        BaseTypeKind::Union { name, .. } => format!("'{}'", name),
        BaseTypeKind::Enum { backing_id, .. } => {
            // enums must use their underlying integer type in Koffi
            // Koffi doesn't recognize enum type names
            let backing_type = type_registry
                .get_type(*backing_id)
                .ok_or_else(|| anyhow!("Enum backing type not found"))?;

            match &backing_type.kind {
                BaseTypeKind::Primitive { name, .. } => primitive_to_koffi(name)?,
                _ => "'int'".to_string(), // default fallback
            }
        }
        BaseTypeKind::Array {
            element_type_id,
            count,
            ..
        } => {
            let elem_type = type_to_koffi_string(type_registry, *element_type_id)?;
            return Ok(format!("koffi.array({}, {})", elem_type, count));
        }
        BaseTypeKind::Typedef {
            name,
            aliased_type_id,
        } => {
            // check what the typedef points to
            let aliased = type_registry
                .get_type(*aliased_type_id)
                .ok_or_else(|| anyhow!("Aliased type not found"))?;

            // if typedef points to function pointer, keep the typedef name
            if aliased.pointer_depth > 0 {
                if let BaseTypeKind::Function { .. } = &aliased.kind {
                    // function pointer typedef - use typedef name
                    format!("'{}'", name)
                } else {
                    // pointer to something else - recursively resolve
                    return type_to_koffi_string(type_registry, *aliased_type_id);
                }
            } else {
                // not a pointer - check if it's an enum or other type
                match &aliased.kind {
                    BaseTypeKind::Enum { .. } => {
                        // Typedef to enum - resolve to underlying int type
                        return type_to_koffi_string(type_registry, *aliased_type_id);
                    }
                    BaseTypeKind::Struct { .. } | BaseTypeKind::Union { .. } => {
                        // typedef to struct/union - use typedef name for convenience
                        format!("'{}'", name)
                    }
                    _ => {
                        // other typedefs - recursively resolve
                        return type_to_koffi_string(type_registry, *aliased_type_id);
                    }
                }
            }
        }
        BaseTypeKind::Function { .. } => "'void *'".to_string(), // Function pointers as void*
    };

    // insert pointer stars inside the string literal if type_str is quoted (e.g., 'void')
    if type_str.starts_with("'") && type_str.ends_with("'") && type_.pointer_depth > 0 {
        // Remove trailing quote
        let mut s = type_str[..type_str.len() - 1].to_string();
        for _ in 0..type_.pointer_depth {
            s.push_str(" *");
        }
        s.push('\'');
        type_str = s;
    } else {
        // fallback: append pointer stars outside
        for _ in 0..type_.pointer_depth {
            type_str.push_str(" *");
        }
    }

    // add const if needed (for documentation, doesn't affect ABI)
    if type_.is_const
        && type_.pointer_depth > 0
        && type_str.starts_with("'")
        && type_str.ends_with("'")
    {
        // Insert const after opening quote
        type_str = format!("'const {}", &type_str[1..]);
    }

    Ok(type_str)
}

/// map C primitive type names to Koffi type strings. Note DWARF normalizes
/// type names so these are a subset of what's possible in C code.
fn primitive_to_koffi(c_name: &str) -> Result<String> {
    let koffi_type = match c_name {
        "void" => "'void'",
        "_Bool" => "'bool'",
        "char" => "'char'",
        "signed char" => "'char'",
        "unsigned char" => "'uchar'",
        "short" => "'short'",
        "unsigned short" => "'ushort'",
        "int" => "'int'",
        "unsigned int" => "'uint'",
        "long" => "'long'",
        "unsigned long" => "'ulong'",
        "long long" => "'longlong'",
        "unsigned long long" => "'ulonglong'",
        "float" => "'float'",
        "double" => "'double'",
        "long double" => "'double'",

        // fixed-width integer types (from <stdint.h>)
        "int8_t" => "'int8_t'",
        "uint8_t" => "'uint8_t'",
        "int16_t" => "'int16_t'",
        "uint16_t" => "'uint16_t'",
        "int32_t" => "'int32_t'",
        "uint32_t" => "'uint32_t'",
        "int64_t" => "'int64_t'",
        "uint64_t" => "'uint64_t'",

        // standard library types (from <stddef.h>)
        "size_t" => "'size_t'",
        "ssize_t" => "'int64_t'",
        "ptrdiff_t" => "'int64_t'",
        "intptr_t" => "'int64_t'",
        "uintptr_t" => "'uint64_t'",

        _ => {
            return Err(anyhow!("unknown primitive type for Koffi: {}", c_name));
        }
    };

    Ok(koffi_type.to_string())
}

/// generate koffi.proto() definitions for callback types
fn generate_callback_protos(
    type_registry: &TypeRegistry,
    callbacks: &[(String, TypeId)],
) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Callback function pointer types\n");

    for (typedef_name, func_ptr_type_id) in callbacks {
        let func_ptr_type = type_registry
            .get_type(*func_ptr_type_id)
            .ok_or_else(|| anyhow!("Function pointer type not found"))?;

        if let BaseTypeKind::Function {
            return_type_id,
            parameter_type_ids,
            ..
        } = &func_ptr_type.kind
        {
            // build the callback signature
            let mut sig = String::new();

            // return type
            if let Some(ret_id) = return_type_id {
                let ret_str = type_to_koffi_c_string(type_registry, *ret_id)?;
                sig.push_str(&ret_str);
            } else {
                sig.push_str("void");
            }
            sig.push(' ');

            // callback name
            sig.push_str(typedef_name);
            sig.push('(');

            // parameters
            if parameter_type_ids.is_empty() {
                sig.push_str("void");
            } else {
                for (i, param_id) in parameter_type_ids.iter().enumerate() {
                    if i > 0 {
                        sig.push_str(", ");
                    }
                    let param_str = type_to_koffi_c_string(type_registry, *param_id)?;
                    sig.push_str(&param_str);
                }
            }

            sig.push(')');

            output.push_str(&format!(
                "const {} = koffi.proto('{}')\n",
                typedef_name, sig
            ));
        }
    }

    output.push('\n');

    Ok(output)
}

/// generate function bindings using lib.func() with C signatures
fn generate_function_bindings(
    type_registry: &TypeRegistry,
    functions: &[FunctionSignature],
    library_path: &str,
) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Library path - UPDATE THIS to match your deployment\n");
    output.push_str(&format!("const LIBRARY_PATH = '{}'\n\n", library_path));

    output.push_str("// Load library\n");
    output.push_str("const lib = koffi.load(LIBRARY_PATH)\n\n");

    output.push_str("// Function bindings\n");

    for func in functions {
        if func.is_variadic {
            // Variadic functions not supported
            output.push_str(&format!(
                "// {}: variadic function not supported by Koffi\n",
                func.name
            ));
            continue;
        }

        // generate Koffi-compatible C signature
        // (cannot use DWARF signature directly - enums/callbacks need special handling)
        let koffi_signature = func_to_koffi_signature(type_registry, func)?;

        output.push_str(&format!(
            "const {} = lib.func('{}')\n",
            func.name, koffi_signature
        ));
    }

    output.push('\n');

    Ok(output)
}

/// convert a function signature to Koffi-compatible C signature string
/// differences from DWARF signature:
/// - Enum types replaced with underlying integer types
/// - Function pointer parameters get * suffix (e.g., Callback*)
fn func_to_koffi_signature(
    type_registry: &TypeRegistry,
    func: &FunctionSignature,
) -> Result<String> {
    let mut sig = String::new();

    // return type
    let return_type_str = type_to_koffi_c_string(type_registry, func.return_type_id)?;
    sig.push_str(&return_type_str);
    sig.push(' ');

    // function name
    sig.push_str(&func.name);
    sig.push('(');

    // parameters
    if func.parameters.is_empty() {
        sig.push_str("void");
    } else {
        for (i, param) in func.parameters.iter().enumerate() {
            if i > 0 {
                sig.push_str(", ");
            }
            let param_type_str = type_to_koffi_c_string(type_registry, param.type_id)?;
            sig.push_str(&param_type_str);
            if !param.name.is_empty() {
                sig.push(' ');
                sig.push_str(&param.name);
            }
        }
    }

    sig.push(')');

    Ok(sig)
}

/// convert a type to Koffi-compatible C type string for function signatures
/// this is different from type_to_koffi_string() which is for struct fields
fn type_to_koffi_c_string(type_registry: &TypeRegistry, type_id: TypeId) -> Result<String> {
    let type_ = type_registry
        .get_type(type_id)
        .ok_or_else(|| anyhow!("Type not found: {:?}", type_id))?;

    // special case: typedef to function pointer
    // Koffi needs "TypedefName*" for callback parameters (with * suffix)
    if let BaseTypeKind::Typedef {
        name,
        aliased_type_id,
    } = &type_.kind
    {
        let aliased = type_registry.get_type(*aliased_type_id);
        if let Some(aliased_type) = aliased {
            // check if this typedef points to a function pointer
            if aliased_type.pointer_depth > 0
                && let BaseTypeKind::Function { .. } = &aliased_type.kind
            {
                // this is a callback typedef (e.g., Callback, Comparator)
                // Koffi requires "Callback*" syntax when used as parameter
                return Ok(format!("{}*", name));
            }
        }
    }

    let mut type_str = match &type_.kind {
        BaseTypeKind::Primitive { name, .. } => {
            // map DWARF type names to Koffi-compatible C type names
            // Koffi has specific expectations for type names in function signatures
            match name.as_str() {
                "_Bool" => "bool".to_string(),
                "signed char" => "char".to_string(),
                "long double" => "double".to_string(),
                _ => name.clone(),
            }
        }
        BaseTypeKind::Struct { name, .. } => name.clone(),
        BaseTypeKind::Union { name, .. } => name.clone(),
        BaseTypeKind::Enum { backing_id, .. } => {
            // replace enum with underlying integer type
            let backing_type = type_registry
                .get_type(*backing_id)
                .ok_or_else(|| anyhow!("Enum backing type not found"))?;

            match &backing_type.kind {
                BaseTypeKind::Primitive { name, .. } => name.clone(),
                _ => "int".to_string(),
            }
        }
        BaseTypeKind::Array {
            element_type_id, ..
        } => {
            // arrays in function parameters decay to pointers
            // Koffi doesn't accept array syntax like "int[5]*"
            // use the element type - pointer will be added via pointer_depth
            return type_to_koffi_c_string(type_registry, *element_type_id);
        }
        BaseTypeKind::Typedef {
            name,
            aliased_type_id,
        } => {
            // check what the typedef points to
            let aliased = type_registry
                .get_type(*aliased_type_id)
                .ok_or_else(|| anyhow!("Aliased type not found"))?;

            // if typedef points to enum, resolve to underlying int type
            // BUT: if the current type has pointers, we need to add them after recursion
            if let BaseTypeKind::Enum { .. } = &aliased.kind {
                // recursively resolve to get the underlying int type
                let mut base_str = type_to_koffi_c_string(type_registry, *aliased_type_id)?;

                // add any pointer stars from the typedef itself
                for _ in 0..type_.pointer_depth {
                    base_str.push('*');
                }

                // add const if needed
                if type_.is_const {
                    base_str = format!("const {}", base_str);
                }

                return Ok(base_str);
            }

            // for typedef to struct/union, use the typedef name
            // (don't recurse, or we'll get anonymous struct names like "<anonymous>")
            match &aliased.kind {
                BaseTypeKind::Struct { .. } | BaseTypeKind::Union { .. } => {
                    // use typedef name to avoid anonymous struct names
                    name.clone()
                }
                _ => {
                    // for other types (primitives, etc), recurse
                    let mut base_str = type_to_koffi_c_string(type_registry, *aliased_type_id)?;

                    // add any pointer stars from the typedef itself
                    for _ in 0..type_.pointer_depth {
                        base_str.push('*');
                    }

                    // add const if needed
                    if type_.is_const {
                        base_str = format!("const {}", base_str);
                    }

                    return Ok(base_str);
                }
            }
        }
        BaseTypeKind::Function { .. } => {
            // bare function pointers (not typedef'd)
            // use void* as fallback
            "void".to_string() // will add * via pointer_depth
        }
    };

    // add pointer stars
    for _ in 0..type_.pointer_depth {
        type_str.push('*');
    }

    // add const qualifier if needed (before type)
    if type_.is_const {
        type_str = format!("const {}", type_str);
    }

    Ok(type_str)
}

fn generate_exports(
    generate_types: bool,
    generate_functions: bool,
    generated_names: &HashSet<String>,
    functions: &[FunctionSignature],
) -> Result<String> {
    let mut output = String::new();

    output.push_str("// Exports\n");
    output.push_str("module.exports = {\n");

    if generate_functions {
        // export types under 'types' namespace and individual functions
        if generate_types {
            output.push_str("  types: {\n");

            for name in generated_names {
                output.push_str(&format!("    {},\n", name));
            }

            output.push_str("  },\n");
        }

        // export individual functions
        for func in functions {
            if !func.is_variadic {
                output.push_str(&format!("  {},\n", func.name));
            }
        }
    } else if generate_types {
        // export types directly
        for name in generated_names {
            output.push_str(&format!("  {},\n", name));
        }
    }

    output.push_str("}\n");

    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_primitive_to_koffi_void() {
        assert_eq!(primitive_to_koffi("void").unwrap(), "'void'");
    }

    #[test]
    fn test_primitive_to_koffi_boolean() {
        assert_eq!(primitive_to_koffi("_Bool").unwrap(), "'bool'");
    }

    #[test]
    fn test_primitive_to_koffi_char_types() {
        assert_eq!(primitive_to_koffi("char").unwrap(), "'char'");
        assert_eq!(primitive_to_koffi("signed char").unwrap(), "'char'");
        assert_eq!(primitive_to_koffi("unsigned char").unwrap(), "'uchar'");
    }

    #[test]
    fn test_primitive_to_koffi_short_types() {
        assert_eq!(primitive_to_koffi("short").unwrap(), "'short'");
        assert_eq!(primitive_to_koffi("unsigned short").unwrap(), "'ushort'");
    }

    #[test]
    fn test_primitive_to_koffi_int_types() {
        assert_eq!(primitive_to_koffi("int").unwrap(), "'int'");
        assert_eq!(primitive_to_koffi("unsigned int").unwrap(), "'uint'");
    }

    #[test]
    fn test_primitive_to_koffi_long_types() {
        assert_eq!(primitive_to_koffi("long").unwrap(), "'long'");
        assert_eq!(primitive_to_koffi("unsigned long").unwrap(), "'ulong'");
    }

    #[test]
    fn test_primitive_to_koffi_long_long_types() {
        assert_eq!(primitive_to_koffi("long long").unwrap(), "'longlong'");
        assert_eq!(
            primitive_to_koffi("unsigned long long").unwrap(),
            "'ulonglong'"
        );
    }

    #[test]
    fn test_primitive_to_koffi_floating_point() {
        assert_eq!(primitive_to_koffi("float").unwrap(), "'float'");
        assert_eq!(primitive_to_koffi("double").unwrap(), "'double'");
        // long double maps to double (Koffi limitation)
        assert_eq!(primitive_to_koffi("long double").unwrap(), "'double'");
    }

    #[test]
    fn test_primitive_to_koffi_fixed_width_types() {
        assert_eq!(primitive_to_koffi("int8_t").unwrap(), "'int8_t'");
        assert_eq!(primitive_to_koffi("uint8_t").unwrap(), "'uint8_t'");
        assert_eq!(primitive_to_koffi("int16_t").unwrap(), "'int16_t'");
        assert_eq!(primitive_to_koffi("uint16_t").unwrap(), "'uint16_t'");
        assert_eq!(primitive_to_koffi("int32_t").unwrap(), "'int32_t'");
        assert_eq!(primitive_to_koffi("uint32_t").unwrap(), "'uint32_t'");
        assert_eq!(primitive_to_koffi("int64_t").unwrap(), "'int64_t'");
        assert_eq!(primitive_to_koffi("uint64_t").unwrap(), "'uint64_t'");
    }

    #[test]
    fn test_primitive_to_koffi_stddef_types() {
        assert_eq!(primitive_to_koffi("size_t").unwrap(), "'size_t'");
        assert_eq!(primitive_to_koffi("ssize_t").unwrap(), "'int64_t'");
        assert_eq!(primitive_to_koffi("ptrdiff_t").unwrap(), "'int64_t'");
        assert_eq!(primitive_to_koffi("intptr_t").unwrap(), "'int64_t'");
        assert_eq!(primitive_to_koffi("uintptr_t").unwrap(), "'uint64_t'");
    }

    #[test]
    fn test_primitive_to_koffi_rejects_unnormalized_variants() {
        // These are variants that DWARF never produces (already normalized by compiler)
        // The function should reject them since they won't appear in practice
        assert!(primitive_to_koffi("short int").is_err());
        assert!(primitive_to_koffi("signed short").is_err());
        assert!(primitive_to_koffi("signed short int").is_err());
        assert!(primitive_to_koffi("unsigned short int").is_err());
        assert!(primitive_to_koffi("short unsigned int").is_err());
        assert!(primitive_to_koffi("long int").is_err());
        assert!(primitive_to_koffi("signed long").is_err());
        assert!(primitive_to_koffi("signed long int").is_err());
        assert!(primitive_to_koffi("unsigned long int").is_err());
        assert!(primitive_to_koffi("long unsigned int").is_err());
        assert!(primitive_to_koffi("long long int").is_err());
        assert!(primitive_to_koffi("signed long long").is_err());
        assert!(primitive_to_koffi("signed long long int").is_err());
        assert!(primitive_to_koffi("unsigned long long int").is_err());
        assert!(primitive_to_koffi("signed int").is_err());
        assert!(primitive_to_koffi("signed").is_err());
        assert!(primitive_to_koffi("unsigned").is_err());
    }

    #[test]
    fn test_primitive_to_koffi_rejects_unknown_types() {
        assert!(primitive_to_koffi("unknown_type").is_err());
        assert!(primitive_to_koffi("string").is_err());
        assert!(primitive_to_koffi("bool").is_err()); // should be _Bool
    }

    /// Test that covers all types that DWARF actually produces.
    /// This list is based on analysis of GCC/Clang DWARF output.
    #[test]
    fn test_primitive_to_koffi_all_dwarf_types() {
        // All the types that DWARF base_type entries actually contain
        let dwarf_types = vec![
            "void",
            "_Bool",
            "char",
            "signed char",
            "unsigned char",
            "short",
            "unsigned short",
            "int",
            "unsigned int",
            "long",
            "unsigned long",
            "long long",
            "unsigned long long",
            "float",
            "double",
            "long double",
        ];

        for type_name in dwarf_types {
            assert!(
                primitive_to_koffi(type_name).is_ok(),
                "Failed to map DWARF type: {}",
                type_name
            );
        }
    }
}
